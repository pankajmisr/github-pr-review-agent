# agent.py

"""
Main implementation of the GitHub PR Review Agent using Google's Agent Development Kit (ADK).
"""

import os
import logging
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
from dotenv import load_dotenv

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
import google.genai as genai
from google.genai import types

# Import GitHub tools
from github_tools import (
    get_pr_details,
    get_pr_files,
    submit_pr_review,
    add_pr_comment
)

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# GitHub token from environment variables
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
if not GITHUB_TOKEN:
    raise ValueError("GITHUB_TOKEN environment variable is not set")

# Google API key
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
if GOOGLE_API_KEY:
    genai.configure(api_key=GOOGLE_API_KEY)

# ADK model configuration
MODEL_NAME = os.getenv("MODEL_NAME", "gemini-2.0-pro")

# App name for the ADK runner
APP_NAME = "github_pr_review_agent"
USER_ID = "user_1"

# Create session service for managing conversation state
session_service = InMemorySessionService()

def analyze_code_changes(pr_files: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Analyzes code changes in a pull request and provides feedback.
    
    Args:
        pr_files (list): List of files changed in the pull request
        
    Returns:
        dict: Analysis results with suggestions and concerns
    """
    # Log tool execution for debugging
    print(f"--- Tool: analyze_code_changes called with {len(pr_files)} files ---")
    
    # Extract basic statistics
    stats = {
        "total_files": len(pr_files),
        "files_by_type": {},
        "total_additions": sum(f.get("additions", 0) for f in pr_files),
        "total_deletions": sum(f.get("deletions", 0) for f in pr_files),
        "total_changes": sum(f.get("changes", 0) for f in pr_files),
    }
    
    # Count files by type
    for file in pr_files:
        filename = file.get("filename", "")
        if "." in filename:
            ext = filename.split(".")[-1]
            stats["files_by_type"][ext] = stats["files_by_type"].get(ext, 0) + 1
    
    # Format the files data for the LLM to analyze
    files_data = []
    for file in pr_files:
        if file.get("error"):
            continue
            
        file_data = {
            "filename": file.get("filename"),
            "status": file.get("status"),
            "changes": file.get("changes"),
            "patch": file.get("patch", "")[:2000],  # Limit patch size
        }
        
        # Include content for smaller files
        if file.get("content") and len(file.get("content", "")) < 10000:
            file_data["content"] = file.get("content")
            
        files_data.append(file_data)
    
    return {
        "stats": stats,
        "files": files_data
    }

def generate_review_from_analysis(analysis_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generates review comments based on the code analysis.
    
    Args:
        analysis_result (dict): Results from the code analysis
        
    Returns:
        dict: Generated review with summary and comments
    """
    # Log tool execution for debugging
    print(f"--- Tool: generate_review_from_analysis called ---")
    
    # This function will be called by the LLM through tool use
    # The actual review generation will be done by the LLM
    return {
        "analysis_received": True,
        "stats": analysis_result.get("stats", {}),
        "file_count": len(analysis_result.get("files", [])),
    }

def format_review_for_submission(
    review_data: Dict[str, Any],
    repo_owner: str,
    repo_name: str,
    pr_number: int
) -> Dict[str, Any]:
    """
    Formats the review data for submission to GitHub.
    
    Args:
        review_data (dict): Review data generated by the agent
        repo_owner (str): Repository owner
        repo_name (str): Repository name
        pr_number (int): Pull request number
        
    Returns:
        dict: Formatted review data ready for submission
    """
    # Log tool execution for debugging
    print(f"--- Tool: format_review_for_submission called ---")
    
    # This will be used to format the review data from the LLM into the format
    # expected by the GitHub API
    return {
        "ready_for_submission": True,
        "repo_owner": repo_owner,
        "repo_name": repo_name,
        "pr_number": pr_number,
        "review_body": review_data.get("summary", ""),
        "event": review_data.get("decision", "COMMENT"),
        "comments": review_data.get("comments", [])
    }

def create_pr_review_agent() -> Agent:
    """
    Creates and configures the PR review agent with tools and instructions.
    
    Returns:
        Agent: Configured PR review agent
    """
    # Define the agent's tools
    tools = [
        get_pr_details,
        get_pr_files,
        analyze_code_changes,
        generate_review_from_analysis,
        format_review_for_submission,
        submit_pr_review,
        add_pr_comment
    ]
    
    # Create the agent with detailed instructions
    agent = Agent(
        model=MODEL_NAME,
        name="github_pr_review_agent",
        description="Provides code review and feedback for GitHub pull requests.",
        instruction="""
        You are a GitHub Pull Request Review Assistant that helps developers by reviewing code changes.
        Your goal is to provide constructive feedback and identify potential issues in the code.
        
        When reviewing code:
        1. Use the get_pr_details tool to get information about the PR
        2. Use the get_pr_files tool to get the files changed in the PR
        3. Use the analyze_code_changes tool to process and analyze the files
        4. Use the generate_review_from_analysis tool to create a structured review
        5. Use the format_review_for_submission tool to prepare the review for GitHub
        6. Use the submit_pr_review or add_pr_comment tool to send feedback to GitHub
        
        Analyze the response from each tool before proceeding to the next step.
        
        Your review should categorize issues as:
        - Critical: Issues that will cause errors or security vulnerabilities
        - High: Issues that should be fixed before merging
        - Medium: Recommendations that would improve code quality
        - Low: Minor suggestions or style improvements
        
        Your tone should be professional, helpful, and educational. Always explain why something 
        is an issue and how it can be improved, not just that it's wrong.
        """,
        tools=tools
    )
    
    return agent

async def review_pull_request(
    repo_owner: str, 
    repo_name: str, 
    pr_number: int,
    user_id: str = USER_ID,
) -> None:
    """
    Reviews a GitHub pull request using the PR review agent.
    
    Args:
        repo_owner (str): Repository owner
        repo_name (str): Repository name
        pr_number (int): Pull request number
        user_id (str): User ID for the session
    """
    try:
        # Create the agent
        agent = create_pr_review_agent()
        
        # Create a session ID
        session_id = f"pr_{repo_owner}_{repo_name}_{pr_number}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        # Create a session
        session = session_service.create_session(
            app_name=APP_NAME,
            user_id=user_id,
            session_id=session_id
        )
        
        # Create a runner
        runner = Runner(
            agent=agent,
            app_name=APP_NAME,
            session_service=session_service
        )
        
        # Start the review process
        initial_message = f"Please review the pull request #{pr_number} from the repository {repo_owner}/{repo_name}."
        
        # Prepare the user's message in ADK format
        content = types.Content(role='user', parts=[types.Part(text=initial_message)])
        
        logger.info(f"Starting review of PR #{pr_number} in {repo_owner}/{repo_name}")
        
        # Run the agent asynchronously
        final_response_text = "Agent did not produce a final response."
        
        async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
            # Log event
            logger.info(f"Event: {event.author}, Type: {type(event).__name__}, Final: {event.is_final_response()}")
            
            # Check for final response
            if event.is_final_response():
                if event.content and event.content.parts:
                    final_response_text = event.content.parts[0].text
                elif event.actions and event.actions.escalate:
                    final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
                break
        
        logger.info(f"Agent response: {final_response_text}")
        logger.info(f"PR review completed for {repo_owner}/{repo_name}#{pr_number}")
    
    except Exception as e:
        logger.error(f"Error reviewing PR: {e}")
        raise

def main_sync(repo_owner: str, repo_name: str, pr_number: int):
    """Synchronous wrapper for the async review function"""
    asyncio.run(review_pull_request(repo_owner, repo_name, pr_number))

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="GitHub PR Review Agent")
    parser.add_argument("--owner", required=True, help="Repository owner")
    parser.add_argument("--repo", required=True, help="Repository name")
    parser.add_argument("--pr", required=True, type=int, help="Pull request number")
    
    args = parser.parse_args()
    
    # Run the PR review
    main_sync(args.owner, args.repo, args.pr)
